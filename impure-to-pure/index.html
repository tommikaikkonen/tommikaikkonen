<!doctype html> <html> <head> <meta charset=utf-8> <meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible> <meta name=viewport content="width=device-width,initial-scale=1"> <title>From Impure to Pure Code</title> <link href="../stylesheets/all-23d929c8.css" rel=stylesheet /> <script src="https://use.typekit.net/zfu1yai.js"></script> <script>try{Typekit.load({ async: true });}catch(e){}</script> </head> <body class="impure-to-pure impure-to-pure_index"> <article class=content-wrapper> <h1>From Impure to Pure Code</h1> <p><em>By <a href="/">Tommi Kaikkonen</a> in 2017</em></p> <p><em>How do purely functional languages facilitate inherently impure logic?</em></p> <p>This article answers that question by listing common impure code constructs and their pure counterparts.</p> <p>It&#39;s written in JavaScript (ES6), but the ideas are generally applicable to languages with first class functions and closures.</p> <p>I&#39;m not going to delve too deeply into <em>when</em> these patterns should be used, which largely depends on context. Sometimes refactoring to pure code may make it easier to test, reason about, and understand. Other times it may make it slower, harder to grasp, and harder to debugâ€”however, it is beneficial to be aware of these patterns.</p> <p>Pure code is composed out of pure functions. Let&#39;s start by defining what they are.</p> <h2>Defining a Pure Function</h2> <p>We define a pure function by two criteria.</p> <p><strong>1. Given the same arguments, the return value will always be the same.</strong></p> <p>In other words, the function maps its domain, a set of input values, to its codomain, a set of output values. Each input value is associated with at most one output value.</p> <p>This means that the function body may not depend on variables outside its arguments, unless they are constant for the lifetime of the program. If the value of one of these variables changes between two invocations of a function, it could return two different output values for a single input value.</p> <p>Here are some examples of functions that violate this criterion:</p> <pre class="highlight javascript"><code><span class="kd">let</span> <span class="nx">mutableVariable</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1">// This function is impure</span>
<span class="c1">// if 'mutableVariable' ever changes.</span>
<span class="kd">function</span> <span class="nx">fn</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">mutableVariable</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="c1">// output depends on system state, an outside variable</span>
<span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="c1">// output depends on system time, an outside variable</span>
</code></pre> <p><strong>2. Evaluating the function doesn&#39;t result in observable side effects.</strong></p> <p>We can distinguish two types of side effects. The first type consists of effects bounded in the JavaScript runtime:</p> <ul> <li>Modifying a global variable</li> <li>Modifying local scope, such as assigning to a variable</li> <li>Modifying memory in-place, such as assigning to an object property or pushing to an array</li> </ul> <p>These two functions perform these side effects and violate the criterion:</p> <pre class="highlight javascript"><code><span class="kd">let</span> <span class="nx">currentUserId</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">setCurrentUser</span><span class="p">(</span><span class="nx">userId</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">currentUserId</span> <span class="o">=</span> <span class="nx">userId</span><span class="p">;</span> <span class="c1">// modifies a global variable</span>
    <span class="k">return</span> <span class="nx">userId</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">addToArray</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span> <span class="c1">// modifies array in-place</span>
<span class="p">}</span>
</code></pre> <p>The second type consists of effects extending outside the JavaScript runtime:</p> <ul> <li>Making network requests</li> <li>Printing to the terminal</li> <li>Modifying the DOM tree</li> <li>Reading from the filesystem</li> <li>Writing to the filesystem</li> </ul> <p>These functions violate the criterion with the second type of effects:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">getWebpage</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span> <span class="c1">// makes a network request</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Hello world'</span><span class="p">)</span> <span class="c1">// causes an observable side effect in the console</span>

<span class="kd">function</span> <span class="nx">modifyDOM</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">'Hello world'</span><span class="p">);</span> <span class="c1">// modifies the DOM</span>
<span class="p">}</span>
</code></pre> <p>We could say that if none of these side effects occur during a function execution, it must be pure, but that doesn&#39;t hold for long. Everything becomes a side effect when you peel back the layers of abstraction and get closer to the hardware. Those side effects exist to modify state, which is inherent in the physical world. A bit is flipped in-place because you can&#39;t conjure new bits out of thin air, just as you can&#39;t create physical matter out of nothing. Purity is a man-made abstraction that hides the state and side effects underneath, leading us to stronger reasoning about our code.</p> <p>A notable corollary is that if a system already has few states and side effects, purity doesn&#39;t offer much benefit and only serves to restrict us. Thus, purity is best used to manage complexity arising from state.</p> <p>While our criteria may seem strict, they allow the first type of side effects within a function invocation as long as they are not observable by the caller. Here&#39;s an example of such a function:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">copyArray</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">copiedArray</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// modifying local scope</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// modifying local scope</span>
        <span class="nx">copiedArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="c1">// modifies `copiedArray` in-place</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">copiedArray</span><span class="p">;</span>
<span class="p">}</span>
</code></pre> <p>In this case, the return value is initialized to an empty array, appended to in-place to achieve the final value, and returned. No side-effects are visible to the caller.</p> <p>Finally, here are examples of pure functions in the JavaScript standard library:</p> <pre class="highlight javascript"><code><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span> <span class="c1">// Will always return the same value for the same input</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toLowerCase</span> <span class="c1">// returns a new string in lower case</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span> <span class="c1">// assuming that the `mapFn` argument is pure</span>
</code></pre> <p>Now that we&#39;ve agreed on the definition of a pure function, let&#39;s dive into the patterns. While not needed in practice, we will take the time to turn low-level side-effects such as language statements, modifying local scope and mutating values to pure code. This serves an important purpose, because these patterns are the building blocks used to turn more complex side-effects pure.</p> <h2>Global Variables</h2> <p>Instead of referring to global variables inside a function, pass the global environment or a part of it as an argument to the function.</p> <p><strong>Impure</strong></p> <p>This functions violates the second function purity criterion by depending on a value outside of its arguments.</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">getDocument</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">global</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nb">document</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">getDocument</span><span class="p">()</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">getDocument</span><span class="p">(</span><span class="nx">environment</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">environment</span><span class="p">.</span><span class="nb">window</span><span class="p">.</span><span class="nb">document</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">getDocument</span><span class="p">(</span><span class="nx">global</span><span class="p">);</span>
</code></pre> <p>Using this pattern can significantly simplify your tests as you don&#39;t have to mock or monkeypatch global variables for testsâ€”just supply your own value for the environment. However, it may become cumbersome if the globals are needed in only a few places deep in the call stack, as you need to pass the environment to each nested function call if they depend on it.</p> <h2>Variable Assignment</h2> <p>Instead of mutating local scope with a variable assigment, move the rest of the statements in the function body to a new function with a single argument, and call it with the value of the variable.</p> <p><strong>Impure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">doubleAndAddTen</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">doubled</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">doubled</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">doubleAndAddTen</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">doubled</span> <span class="o">=&gt;</span> <span class="nx">doubled</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)(</span><span class="nx">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre> <p>The <code>doubled</code> binding is now a function parameter, which doesn&#39;t modify the local scope for <code>doubleAndAddTen</code>.</p> <p>This pattern is of little practical use by itself, but it&#39;s an elementary building block used to turn loops pure, as well as sequencing side effects.</p> <h2>Loops</h2> <p>Instead of mutating local scope during a loop, the loop body can be turned into a recursive function <code>loop</code> that accepts all loop variables as arguments, starting with the initial values, and calls itself until the loop is finished, and returns the final values for all the loop variables.</p> <p><strong>Impure</strong></p> <pre class="highlight javascript"><code><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">loop</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">loop</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">loop</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre> <p>Do not use this pattern in a language without tail call optimization, as each loop iteration will add a call to the stack, leading to stack overflow on long loops.</p> <h2>Exceptions</h2> <p>Instead of throwing exceptions, indicate exceptional states in the return value. Here, <code>safeDivide</code> performs division, but returns <code>0</code> in case the division throws an error.</p> <p><strong>Impure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">divide</span><span class="p">(</span><span class="nx">dividend</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">divisor</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Can't divide by 0."</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">dividend</span> <span class="o">/</span> <span class="nx">divisor</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">safeDivide</span><span class="p">(</span><span class="nx">dividend</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">dividend</span> <span class="o">/</span> <span class="nx">divisor</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre> <blockquote> <p>We could think of exceptions as another possible return value that is implicitly propagated up the call stack unless the return value is explicitly handled with a <code>try/catch</code> construct. As such, they may be considered pure.</p> </blockquote> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">divide</span><span class="p">(</span><span class="nx">dividend</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">divisor</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">ok</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="na">value</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Can't divide by 0"</span><span class="p">).</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">ok</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">value</span><span class="p">:</span> <span class="nx">dividend</span> <span class="o">/</span> <span class="nx">divisor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">safeDivide</span><span class="p">(</span><span class="nx">dividend</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">divide</span><span class="p">(</span><span class="nx">dividend</span><span class="p">,</span> <span class="nx">divisor</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre> <p>In this pattern, the function caller must know how to distinguish a normal return value from an error value. This is done using the <code>ok</code> property. Unless we add another layer of abstraction, all calls to functions that produce these kind of return values must explicitly handle both value types, which adds boilerplate.</p> <h2>Mutating In-Place</h2> <p>Instead of mutating state in-place, return a new, updated value.</p> <p><strong>Impure</strong></p> <p><code>setFirst</code> and <code>setSecond</code> methods mutate the internal state of the instance.</p> <pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">MutablePair</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">second</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">setFirst</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">setSecond</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">second</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MutablePair</span><span class="p">();</span>
<span class="nx">pair</span><span class="p">.</span><span class="nx">setFirst</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">setSecond</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// MutablePair { first: 1, second: 2 }</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">ImmutablePair</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="nx">first</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">second</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="nx">first</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">second</span> <span class="o">=</span> <span class="nx">second</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">setFirst</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">ImmutablePair</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">second</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">setSecond</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">ImmutablePair</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">first</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ImmutablePair</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">finalPair</span> <span class="o">=</span> <span class="nx">pair</span><span class="p">.</span><span class="nx">setFirst</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nx">setSecond</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// ImmutablePair { first: 1, second: 2 }</span>
</code></pre> <p>Some types of values are commonly implemented as immutable in programming languages, such as dates, times, numbers, and strings, because they map well to our understanding. For example, a date does not have state to mutate; it is what it is, it cannot be changed. We can calculate new dates based on a starting point, but that has no effect on the initial date. As a result, this pattern is common in both imperative and functional languages.</p> <h2>Stateful Computations</h2> <p>Instead of holding state in variables that change value after executing statements, pass computation state as an argument to a function, and return the computation result and a new computation state.</p> <p><strong>Impure</strong></p> <p>This function, used to generate sequential integer identifiers, violates both of our function purity criteria.</p> <pre class="highlight javascript"><code><span class="kd">let</span> <span class="nx">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">getNextId</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">state</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">getNextId</span><span class="p">();</span>
<span class="c1">// 0</span>
<span class="nx">getNextId</span><span class="p">();</span>
<span class="c1">// 1</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">getNextId</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="nx">state</span> <span class="cm">/* return value */</span><span class="p">,</span>
        <span class="nx">state</span> <span class="o">+</span> <span class="mi">1</span> <span class="cm">/* next state */</span>
    <span class="p">];</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">initialState</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">firstId</span><span class="p">,</span> <span class="nx">secondState</span><span class="p">]</span> <span class="o">=</span> <span class="nx">getNextId</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
<span class="c1">// [0, 1]</span>

<span class="kr">const</span> <span class="p">[</span><span class="nx">secondId</span><span class="p">,</span> <span class="nx">thirdState</span><span class="p">]</span> <span class="o">=</span> <span class="nx">getNextId</span><span class="p">(</span><span class="nx">secondState</span><span class="p">);</span>
<span class="c1">// [1, 2]</span>
</code></pre> <p>The pure implementation makes <code>getNextId</code> very predictable on each call, but adds a lot of boilerplate to manage all the intermediary states (<code>secondState</code>, <code>thirdState</code>). It is common in purely functional languages to add another layer of abstraction to stateful computations that manages them implicitly, akin to imperative languages.</p> <h2>Managing Inherent Impurity</h2> <p>The forms of impurity we&#39;ve looked at so far can be fully eliminated from our code. However, side effects that extend outside the language runtime can not be eliminated from an application. Further, all applications must have side effects in order to be useful: if a program doesn&#39;t write anything to an output stream, or perform observable side-effects, you might as well not run the program. Instead of letting impurity permeate our business logic, we can hold on to purity for as long as possible and perform side effects at the edge of our application where they won&#39;t affect our ability to reason about code.</p> <p>A practical edge of our application is the <code>main</code> function that initiates program execution, and runs all the side effects we have carefully prepared.</p> <h2>Side Effects</h2> <p>Instead of performing a side effect in a function, return enough information to allow you to perform the side effect later.</p> <p><strong>Impure</strong></p> <p>This function call violates our second criterion for function purity: the caller may observe a side-effect of output in the console.</p> <pre class="highlight javascript"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Logging to the console is a side effect.'</span><span class="p">);</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">pureLog</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">fn</span><span class="p">:</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">,</span>
        <span class="na">args</span><span class="p">:</span> <span class="nx">args</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">sideEffect</span> <span class="o">=</span> <span class="nx">pureLog</span><span class="p">(</span><span class="s1">'Logging to the console is a side effect.'</span><span class="p">);</span>

<span class="c1">// At the periphery of your program,</span>
<span class="c1">// perhaps in your 'main' function.</span>
<span class="nx">sideEffect</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">sideEffect</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span>
</code></pre> <p>The function call is encoded in an object with properties <code>fn</code> and <code>args</code>, and executed later based on those values. Note that this is just one way to encode a side effect. Another simple approach is to return a thunk, a function with zero arguments, that holds the data in a function closure and allows you to call it to perform the side effect:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">pureLog</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">sideEffect</span> <span class="o">=</span> <span class="nx">pureLog</span><span class="p">(</span><span class="s1">'Logging to the console is a side effect.'</span><span class="p">);</span>

<span class="c1">// At the periphery...</span>
<span class="nx">sideEffect</span><span class="p">();</span>
</code></pre> <p>Since this encoding is the simplest, we&#39;ll use it in the following examples. However, in practice you want to encode your side effects explicitly. There are two main reasons for this. First, it makes it possible to change how side effects are executed at runtime. In tests you may want to mock network requests, or read from a mock database. Given this side effect:</p> <pre class="highlight javascript"><code><span class="c1">// Returns a Promise for the JSON parsed response payload.</span>
<span class="nx">async</span> <span class="kd">function</span> <span class="nx">impureGetJSON</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">pureGetValueFromAPI</span><span class="p">(</span><span class="nx">resourceID</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">fn</span><span class="p">:</span> <span class="nx">impureGetJSON</span><span class="p">,</span>
        <span class="na">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">'https://example.com/'</span> <span class="o">+</span> <span class="nx">resourceId</span><span class="p">]</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">sideEffect</span> <span class="o">=</span> <span class="nx">pureGetValueFromAPI</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre> <p>You can implement separate &quot;runners&quot;:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">runNormal</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">effect</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">runTest</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">effect</span><span class="p">.</span><span class="nx">fn</span> <span class="o">===</span> <span class="nx">impureGetJSON</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Mock a response payload for our fetch.</span>
        <span class="kr">const</span> <span class="p">[</span><span class="nx">resourceId</span><span class="p">]</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">args</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">({</span> <span class="na">status</span><span class="p">:</span> <span class="s1">'ok'</span><span class="p">,</span> <span class="na">id</span><span class="p">:</span> <span class="nx">resourceId</span> <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">// If we don't provide a mock for the effect,</span>
    <span class="c1">// fall back to executing it.</span>
    <span class="k">return</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">effect</span><span class="p">.</span><span class="nx">args</span><span class="p">);</span>
<span class="p">}</span>
</code></pre> <p>Second, it allows you to test your logic deterministically, assuming your side effects run correctly. A unit test for <code>pureGetValueFromAPI</code> would simply be:</p> <pre class="highlight javascript"><code><span class="nx">expect</span><span class="p">(</span><span class="nx">pureGetValueFromAPI</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">to</span><span class="p">.</span><span class="nx">deep</span><span class="p">.</span><span class="nx">equal</span><span class="p">({</span>
    <span class="na">fn</span><span class="p">:</span> <span class="nx">impureGetJSON</span><span class="p">,</span>
    <span class="na">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">'https://example.com/1'</span><span class="p">]</span>
<span class="p">})</span>
</code></pre> <p>This example is of course simple enough not to warrant much testing, but the utility quickly increases with complexity. For example, <a href="(https://redux-saga.js.org/docs/basics/DeclarativeEffects.html)"><code>redux-saga</code> uses this pattern to allow testing complex asynchronous flows with side effects</a>.</p> <h2>Sequenced Side Effects</h2> <p>Instead of using two sequential statements to perform two side effects one after the other, force the sequence evaluation order using expression evaluation order: arguments in a function call must be evaluated before the function body.</p> <p><strong>Impure</strong></p> <pre class="highlight javascript"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'One'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Two'</span><span class="p">);</span>
<span class="c1">// Output:</span>
<span class="c1">// One</span>
<span class="c1">// Two</span>
</code></pre> <p><strong>Pure</strong></p> <p>Here we use thunks with closures to encode side effects as data, like we saw in the previous section:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">pureLog</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">sideEffectOne</span> <span class="o">=</span> <span class="nx">pureLog</span><span class="p">(</span><span class="s1">'One'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">sideEffectTwo</span> <span class="o">=</span> <span class="nx">pureLog</span><span class="p">(</span><span class="s1">'Two'</span><span class="p">);</span>
</code></pre> <p>Using statements, we would do:</p> <pre class="highlight javascript"><code><span class="nx">sideEffectOne</span><span class="p">();</span>
<span class="nx">sideEffectTwo</span><span class="p">();</span>
<span class="c1">// Output:</span>
<span class="c1">// One</span>
<span class="c1">// Two</span>
</code></pre> <p>But we can turn this into a single expression:</p> <pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">sideEffectSequence</span> <span class="o">=</span> <span class="p">(</span><span class="nx">firstEffect</span><span class="p">,</span> <span class="nx">secondEffect</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">ignoredReturnValue</span> <span class="o">=&gt;</span> <span class="nx">secondEffect</span><span class="p">())(</span><span class="nx">firstEffect</span><span class="p">());</span>

<span class="kr">const</span> <span class="nx">sequencedSideEffect</span> <span class="o">=</span> <span class="nx">sideEffectSequence</span><span class="p">(</span><span class="nx">pureLog</span><span class="p">(</span><span class="s1">'One'</span><span class="p">),</span> <span class="nx">pureLog</span><span class="p">(</span><span class="s1">'Two'</span><span class="p">));</span>

<span class="nx">sequencedSideEffect</span><span class="p">();</span>
<span class="c1">// Output:</span>
<span class="c1">// One</span>
<span class="c1">// Two</span>
</code></pre> <h2>Sequencing Dependent Side Effects</h2> <p>Instead of saving side effect results, such as lines from a file or user input from a stream, in a variable and using the variable value in the following statement, use expression evaluation order to force the sequence and delay determining the second side effect until the first side effect result is resolved.</p> <p>This is a small but powerful adjustment to the previous pattern.</p> <p><strong>Impure</strong></p> <p>Here, we prompt the user for their name in a dialog, and output it to the console. The second effect depends on a value produced in the first.</p> <pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Hey</span> <span class="nx">$</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">);</span>
</code></pre> <p><strong>Pure</strong></p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">purePrompt</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">pureGreet</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Hey</span> <span class="nx">$</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">chainSideEffects</span> <span class="o">=</span> <span class="p">(</span><span class="nx">firstEffect</span><span class="p">,</span> <span class="nx">decideSecondEffect</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">decideSecondEffect</span><span class="p">(</span><span class="nx">firstEffect</span><span class="p">())();</span>

<span class="kr">const</span> <span class="nx">sideEffect</span> <span class="o">=</span> <span class="nx">chainSideEffects</span><span class="p">(</span>
    <span class="nx">purePrompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">),</span>
    <span class="nx">pureGreet</span>
<span class="p">);</span>

<span class="nx">sideEffect</span><span class="p">();</span>
</code></pre> <p>Due to the expression evaluation order, <code>firstEffect</code>, or the prompt for the user name, is performed first. The return value of that function will be the name entered by the user. That value is passed to <code>pureGreet</code>, which is bound to the argument name <code>decideSecondEffect</code>. To fully understand the process, let&#39;s expand the definition for <code>sideEffect</code>:</p> <pre class="highlight javascript"><code><span class="c1">// Starting point.</span>
<span class="kd">let</span> <span class="nx">sideEffect</span> <span class="o">=</span> <span class="nx">chainSideEffects</span><span class="p">(</span>
    <span class="nx">purePrompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">),</span>
    <span class="nx">pureGreet</span>
<span class="p">);</span>
<span class="c1">// Expand the definition of chainSideEffects</span>
<span class="nx">sideEffect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">pureGreet</span><span class="p">(</span><span class="nx">purePrompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">)())();</span>
<span class="c1">// Expand purePrompt</span>
<span class="nx">sideEffect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">pureGreet</span><span class="p">((()</span> <span class="o">=&gt;</span> <span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">))())();</span>
<span class="c1">// Replace (() =&gt; X)() with X in the purePrompt definition</span>
<span class="nx">sideEffect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">pureGreet</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">))();</span>
<span class="c1">// Expand pureGreet</span>
<span class="nx">sideEffect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
    <span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Hey</span> <span class="nx">$</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">))(</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">)</span>
    <span class="p">)();</span>
<span class="c1">// Remove one redundant thunk layer</span>
<span class="nx">sideEffect</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span>
    <span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Hey</span> <span class="nx">$</span><span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!</span><span class="err">`</span><span class="p">))(</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">prompt</span><span class="p">(</span><span class="s1">'Please enter your name'</span><span class="p">)</span>
    <span class="p">);</span>
</code></pre> <p>As we can see from the expanded definition, it looks almost identical to the pure code in <em>Variable Assignments</em>, except that instead of binding a value returned from a pure function, we&#39;re binding a result from a side-effect and wrapping the procedure in a thunk.</p> <h2>Statements</h2> <p>Whereas expressions evaluate to a value, statements don&#39;t evaluate to anything. They direct the runtime to perform a side effect. For example, a variable assignment directs the language runtime to bind a value to a name in the current scope. An assertion statement directs the language runtime to throw an exception if the guard value is falsy. The return statement directs the runtime to exit the function, assigning the return value of the function according to the statement.</p> <p>These are all side effects. The order of the statements determines in which order those effects are performed. Often a statement depends on a side-effect performed by a previous statement, such as a variable being assigned before using it.</p> <p>The two previous sections described how we can perform one side effect after the other. <em>That&#39;s what statements are</em>. We&#39;ve already turned statements pure. <code>chainSideEffects</code> in the previous section implements the idea of a semicolon: first do this; then that. Instead of being restricted to how the language runtime decides to implement semicolons, we can decide for ourselves. Haskell, for example, provides syntactic sugar for writing statements that are turned to pure expressions with the <code>do</code> notation, but letting the programmer decide what the semicolon means.</p> <h2>Composing Applications with Pure Functions</h2> <p>We have examined patterns that can turn the vast majority of application code pure. Applying these patterns is not hard at allâ€”it is more difficult to learn how to compose applications with pure functions. It can definitely be done, but the tools are <em>very</em> different than control flow in imperative languages.</p> <p>Normal function composition is straightforward. It is the glue that holds together pieces of a functional application. It combines two functions <code>f</code> and <code>g</code> into a function <code>fg</code> that pipes a value <code>x</code> through these two functions, first applying <code>g</code> to the value <code>x</code> to yield <code>y</code> and then applying <code>f</code> to <code>y</code> to yield the final return value <code>z</code>. Note that in this notation, the order of function evaluation goes from right to left, from <code>g</code> to <code>f</code>. In JavaScript:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="kr">const</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">z</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// or more succinctly</span>
<span class="kr">const</span> <span class="nx">compose</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</code></pre> <p>This type of composition works when the return type of <code>g</code> matches the argument type for <code>f</code>. For example, you can compose a function that returns a string with a function that accepts a string as an argument.</p> <blockquote> <p>There is no requirement for the types to match in dynamic languages, but to compose functions in a sane manner, it is highly beneficial that returned values satisfy a common interface. For dynamic languages, you can replace interface for type in this section.</p> </blockquote> <p>However, when you turn impure code pure, we&#39;re changing the return type to add more information. Instead of a single value, were returning a value <em>and</em> state information, or a value <em>or</em> error information, or altogether something else like a thunk that can produce a value later. We call these functions <em>effectful</em> computations that produce a result value and one or more other values that describe the effect. Effectful computations can&#39;t use normal function composition because the return and argument types don&#39;t match. Further, what a composition of two effectful computations means needs to be determined for each type of effect.</p> <p>Say we have two computations that may fail, and that we want to compose. Both take a single argument of some type <code>T</code>, and both return a value of type <code>ErrorOrOk&lt;T&gt;</code>, that is the return value includes two pieces of information: a success flag indicating whether a failure occurred, and a value that is either an Error or a normal value depending on the flag. Because <code>ErrorOrOk&lt;T&gt;</code> doesn&#39;t match <code>T</code>, we can&#39;t compose two functions of <code>T -&gt; ErrorOrOk&lt;T&gt;</code>.</p> <p>The common way to define the composition of two functions which may both fail is as follows:</p> <ol> <li>Call the first computation <code>g</code> with the input argument <code>x</code> and go to step 2.</li> <li>If <code>g(x)</code> failed, return <code>g(x)</code>. Otherwise, go to step 3.</li> <li>Let the successful return value of <code>g(x)</code> of type <code>T</code> be <code>y</code> and go to step 4.</li> <li>Call the second computation <code>f</code> with <code>y</code> and return the result.</li> </ol> <p>Which looks like this in JavaScript:</p> <pre class="highlight javascript"><code><span class="kd">function</span> <span class="nx">composeFailable</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">firstResult</span> <span class="o">=</span> <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">firstResult</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">firstResult</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="nx">f</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">firstResult</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre> <p>As each effectful computation needs to implement their own composition, purely functional languages offer generic operations for composition that work an all computations. When an effectful computation implements these generic operations, it is said to form a <em>monad</em>. Because monad operations are commonly used to describe effectful computations in purely functional languages, they&#39;re ubiquitous in that paradigm. However, monads as a concept is more abstract than just effectful computations, which makes it harder to understand intuitively and apply in practice.</p> <h2>Conclusion</h2> <p>We examined common impure code patterns, compared them to their pure counterparts, and discussed the consequences of building applications from smaller parts of pure code. Hopefully this document exposed some of the magic that allows functional languages to conduct imperative operations with pure grace.</p> <p>I don&#39;t recommend fully converting your applications to pure code: use common sense and embrace the strengths of the language you are working in.</p> </article> <footer> <div class=content-wrapper> <p> Follow me on Twitter: <a href="https://twitter.com/tommikaikkonen">@tommikaikkonen</a>.<br/> <a href="/">Back to home</a> </p> </div> </footer> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71106705-1', 'auto');
  ga('send', 'pageview');
</script> </body> </html>