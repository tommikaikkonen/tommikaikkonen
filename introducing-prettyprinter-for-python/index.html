<!doctype html> <html> <head> <meta charset=utf-8> <meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible> <meta name=viewport content="width=device-width,initial-scale=1"> <title>Introducing PrettyPrinter for Python</title> <link href="../stylesheets/all-3c34f8b4.css" rel=stylesheet /> <script src="https://use.typekit.net/zfu1yai.js"></script> <script>try{Typekit.load({ async: true });}catch(e){}</script> </head> <body class="introducing-prettyprinter-for-python introducing-prettyprinter-for-python_index"> <article class=content-wrapper> <h1>Introducing PrettyPrinter for Python</h1> <p><em>By <a href="/">Tommi Kaikkonen</a> in 2017</em></p> <p><a href="https://github.com/tommikaikkonen/prettyprinter">PrettyPrinter</a> is a powerful, syntax-highlighting, and declarative pretty printer for Python 3.6+. It uses a modified Wadler-Leijen layout algorithm, similar to those used in Haskell pretty printer libraries <a href="https://github.com/quchen/prettyprinter"><code>prettyprinter</code></a> and <a href="https://github.com/ekmett/ansi-wl-pprint"><code>ansi-wl-pprint</code></a>, JavaScript&#39;s <a href="https://github.com/prettier/prettier">Prettier</a>, Ruby&#39;s <a href="https://github.com/sj26/ruby-1.9.3-p0/blob/master/lib/prettyprint.rb"><code>prettyprinter.rb</code></a> and IPython&#39;s <a href="http://ipython.readthedocs.io/en/stable/api/generated/IPython.lib.pretty.html"><code>IPython.lib.pretty</code></a>. It combines the best parts of each and builds more on top to produce the most powerful pretty printer in Python to date.</p> <p>Here are some pretty screenshots to demonstrate PrettyPrinter output:</p> <p><img alt="PrettyPrinter output on dark background" src="../images/prettyprinter/screenshot.png"/> <img alt="PrettyPrinter output on light background" src="../images/prettyprinter/lightscreenshot.png"/></p> <h2>Why does Python need another pretty printer?</h2> <p>Printing data to the screen is a developer&#39;s primary interface to values in a runtime, whether that&#39;s done by an IDE or manually by the developer. Improving that interface goes a long way to improve development experience and productivity. Python and third party libraries provide tools to help with that:</p> <ul> <li><strong><code>__repr__</code> and <code>__str__</code> dunder methods</strong> that return plain strings. <code>__repr__</code> should return a syntactically correct Python expression if possible, and is most commonly used to output values that failed test assertions, or values evaluated in the shell. As it is based purely on string formatting, it has no pretty printing capabilities.</li> <li><strong>The standard library module <a href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a></strong> offers pretty-printing facilities for native data types like dicts, lists, tuples, sets, and frozensets. It delegates to <code>__repr__</code> methods of user-defined class instances. However, it has a very greedy layout algorithm that fails to produce pretty output in many cases. Since you&#39;re own pretty printer definitions are restricted to what you can return in <code>__repr__</code>, its capabilities are limited for everything but the native types.</li> <li><strong>The third party library <a href="https://github.com/wolever/pprintpp"><code>pprintpp</code></a></strong> is an improvement and a drop-in replacement for <code>pprint</code> that produces nicer output, but like <code>pprint</code>, restricts used-defined pretty printing to <code>__repr__</code>.</li> <li><strong>The default representation printer in IPython, <a href="http://ipython.readthedocs.io/en/stable/api/generated/IPython.lib.pretty.html"><code>IPython.lib.pretty</code></a></strong>, is intended as an advanced drop-in replacement for <code>pprint</code>. It is a superior implementation to <code>pprint</code> in many ways: the algorithm works well to deliver pretty output in most cases, and it provides tools to define pretty printers for user-defined types that compose well with the rest of the output. However, to implement your own pretty printers, you need to know how the layout algorithm works. Further, the API is inherently side-effectful: calling a pretty printer pushes data directly into a layout buffer, not allowing for easy inspection of layout primitives.</li> </ul> <p>All of the above fall short of what I consider a great pretty printing experience. I set out to make the following improvements:</p> <ul> <li>Implement an algorithm that tries very hard to produce pretty output, even if it takes a bit more work. Taking 1/10th of a second longer to pretty print doesn&#39;t matter if it saves me two seconds when looking at the data to find what I need.</li> <li>Implement a dead simple, declarative interface to writing your own pretty printers. Python developers rarely write <code>__repr__</code> methods because they&#39;re a pain; no one will definitely write pretty printing rules for user-defined types unless it&#39;s super simple.</li> <li>Implement syntax-highlighting that doesn&#39;t break on invalid Python syntax. Not all <code>__repr__</code> methods produce valid syntax, and therefore break normal syntax highlighters.</li> </ul> <p>I was surprised by how well the library turned out. The algorithm works superbly, and is fast enough. To define your own pretty printers, you only need to know two declarative functions, <code>register_pretty</code> and <code>pretty_call</code>. The syntax-highlighting looks beautiful, and doesn&#39;t break on invalid syntax. Especially the syntax-highlighting makes it hard to go back to normal pretty printers, it helps the development experience significantly.</p> <p>The most interesting improvement is the declarative APIâ€”here&#39;s a rundown of how it works.</p> <h2>Simple, declarative API</h2> <p>Defining pretty printers in PrettyPrinter is based on (constructor) function calls. All non-literal Python values should be represented as such. The workhorse function of the library is <code>pretty_call</code>, which allows you to describe what kind of function call PrettyPrinter should output. For example, given the following <code>pretty_call</code> call:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">prettyprinter</span> <span class="kn">import</span> <span class="n">pretty_call</span>

<span class="c"># ctx is available in pretty printer definitions</span>
<span class="n">layout_primitive</span> <span class="o">=</span> <span class="n">pretty_call</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre> <p>When PrettyPrinter processes <code>layout_primitive</code>, it&#39;ll look like this:</p> <pre class="highlight python"><code><span class="nb">sorted</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre> <p>(The <code>ctx</code> passed as the first argument allows you to control how any nested data, in this case the list <code>[5, 3, 6, 1]</code> and the <code>True</code> value in the <code>reverse</code> keyword argument are rendered. Most of the time, it is passed as is.)</p> <p>Given that we understand how to use <code>pretty_call</code>, let&#39;s define our own type:</p> <pre class="highlight python"><code><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">one</span> <span class="o">=</span> <span class="n">one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">two</span> <span class="o">=</span> <span class="n">two</span>
</code></pre> <p>Using the <code>register_pretty</code> decorator, we can define the pretty printer for MyClass:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">prettyprinter</span> <span class="kn">import</span> <span class="n">register_pretty</span><span class="p">,</span> <span class="n">pretty_call</span>

<span class="nd">@register_pretty</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pretty_myclass</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pretty_call</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">MyClass</span><span class="p">,</span> <span class="n">one</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">two</span><span class="p">)</span>
</code></pre> <p>The output from <code>cpprint</code> expectedly is:</p> <pre class="highlight python"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">prettyprinter</span> <span class="kn">import</span> <span class="n">cpprint</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cpprint</span><span class="p">(</span><span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">MyClass</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre> <p>For more examples, see <a href="https://github.com/tommikaikkonen/prettyprinter/blob/master/prettyprinter/pretty_stdlib.py">the PrettyPrinter definition code for standard library types</a>.</p> <h3>Representing stateful instances</h3> <p>A drawback of constructor calls is that they don&#39;t represent stateful instances well. Generally you want some kind of extra output that indicates instance state. PrettyPrinter handles this with declarative comments, a powerful feature I&#39;m pretty excited about. Annotate a Python value (or a layout primitive representing a Python value) with a comment, and the output will magically include the comment next to it in the output.</p> <p>Consider a <code>Connection</code> class with a state that is either open or closed:</p> <pre class="highlight python"><code><span class="k">class</span> <span class="nc">Connection</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hostname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hostname</span> <span class="o">=</span> <span class="n">hostname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_open</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_open</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_open</span> <span class="o">=</span> <span class="bp">False</span>
</code></pre> <p>If we want the following output:</p> <pre class="highlight python"><code><span class="n">Connection</span><span class="p">(</span><span class="s">'http://example.com'</span><span class="p">)</span>  <span class="c"># Status: Open</span>
</code></pre> <p>We can achieve that with the following definition:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">prettyprinter</span> <span class="kn">import</span> <span class="n">register_pretty</span><span class="p">,</span> <span class="n">pretty_call</span><span class="p">,</span> <span class="n">comment</span>

<span class="nd">@register_pretty</span><span class="p">(</span><span class="n">Connection</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pretty_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">status_text</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">'Status: Open'</span>
        <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">is_open</span>
        <span class="k">else</span> <span class="s">'Status: Closed'</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">comment</span><span class="p">(</span>
        <span class="n">pretty_call</span><span class="p">(</span>
            <span class="n">ctx</span><span class="p">,</span>
            <span class="n">Connection</span><span class="p">,</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">hostname</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">status_text</span>
    <span class="p">)</span>
</code></pre> <h2>Conclusion</h2> <p>I&#39;ve enjoyed using PrettyPrinter as a part of my development toolkit. There&#39;s a lot more to it than what I can go through in one article, so I suggest you give it a try! I recommend using it with IPython, as everything you evaluate in the REPL can be automatically printed using PrettyPrinter. The instructions to set that up can be found in the documentation.</p> <p>Check out the <a href="https://github.com/tommikaikkonen/prettyprinter">source code on GitHub</a> and the (still slightly rough) <a href="https://prettyprinter.readthedocs.io/en/latest/">documentation on readthedocs.io</a>. The package includes ready-made definitions for Django Models and QuerySets, as well as any class created using the <a href="http://www.attrs.org/en/stable/"><code>attrs</code> package</a>, so if you&#39;re using either you&#39;ll definitely want to give it a spin!</p> </article> <footer> <div class=content-wrapper> <p> Follow me on Twitter: <a href="https://twitter.com/tommikaikkonen">@tommikaikkonen</a>.<br/> <a href="/">Back to home</a> </p> </div> </footer> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71106705-1', 'auto');
  ga('send', 'pageview');
</script> </body> </html>