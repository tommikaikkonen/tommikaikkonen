<!doctype html> <html> <head> <meta charset=utf-8> <meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible> <meta name=viewport content="width=device-width,initial-scale=1"> <title>Time Zones in Pytz &amp; Django</title> <link href="../stylesheets/all-cb2cba5b.css" rel=stylesheet /> <script src="https://use.typekit.net/zfu1yai.js"></script> <script>try{Typekit.load({ async: true });}catch(e){}</script> </head> <body class="timezones timezones_index"> <article class=content-wrapper> <h1>Time Zones in Pytz &amp; Django</h1> <p><em>By <a href="/">Tommi Kaikkonen</a> in 2015</em></p> <p>Time zones, those stupid things getting in the way of shipping software! If you read the <a href="https://docs.djangoproject.com/en/1.8/topics/i18n/timezones/">Django documentation on time zones</a> and still feel lost, this article is for you. I&#39;ll assume you are familiar with the <code>datetime</code> library and know the difference between naïve and aware <code>datetime</code>s. I&#39;ll also assume you know some Django.</p> <p>In order to understand time zones, we must start from the basics.</p> <h2>Time</h2> <p>Before we had universally synchronized times and timezones, local time was synchronized to movements of the Sun. Noon was when the Sun was at it&#39;s highest point and midnight 12 hours later. Each settlement had their own local times, which could differ by just minutes. This worked fine until trains were invented. Because local times were unsynchronized, trains collided often and schedules confused the passengers. Eventually Railway time was established in England to solve these problems. It was based on local time in London, which you probably know as Greenwich Mean Time or GMT. However, international times were still unsynchronized.</p> <p>In 1876, Canadian engineer Sandford Fleming missed a train in Ireland due to a bad schedule. I guess he was pretty pissed off, since a couple years later he publicly proposed the concept of timezones. He proposed that humans adopt a single universal time, with local time zones being on an offset from it. His idea caught on quick, and 50 years later most countries were using timezones.</p> <p>The concept of universal time still applies. We follow <strong>Coordinated Universal Time</strong>, abbreviated as <strong>UTC</strong>, which for our purposes is equal to GMT. We&#39;ll use UTC over GMT because it is the standard. UTC follows <strong>mean solar time</strong>, give or take a second. You would think that UTC is tracked by astronomists, but it&#39;s actually tracked with an atomic clock. To keep it synchronized with mean solar time, it&#39;s adjusted with leap seconds, forecasted beforehand by astronomists. Recently a leap second has been scheduled every few years.</p> <p>Mean solar time is a convenient simplification of <strong>apparent solar time</strong>, the time a sundial tells you. Here&#39;s what it means.</p> <p><img alt="Mean Solar Time" src="../images/timezones/meansolartime.png"/></p> <p>Let&#39;s look at the world from the Earth&#39;s perspective. In the above image you see an imaginary sun, the Mean Sun, circling around Earth along the celestial equator. It&#39;s that horizontal line splitting world maps in half. The difference is that the real Sun circles around the ecliptic equator due to Earth&#39;s 23.4° axis tilt.</p> <p>Mean solar time within any current day corresponds to the angle <em>β</em> of the Mean Sun to the Earth. We could calculate that angle from anywhere, but by convention we use the longitude at the Prime Meridian, located at the Royal Observatory in Greenwich, London.</p> <p>The corollary is that UTC is the same no matter where we are in the world, what year it is, whether it&#39;s daylight saving time or not. There are no transitions because neither does the Sun suddenly move position, nor does the Earth abruptly rotate <code>360 / 24 == 15</code> degrees. That makes it excellent for all time arithmetic.</p> <h2>Time Zones</h2> <p>Let&#39;s forget UTC exists for a moment and start developing a simple application to be used in a single time zone. To successfully do that, we define what a time zone is.</p> <blockquote> <p>A time zone is a geographical region where almost everyone observes the same standard time. (<a href="https://en.wikipedia.org/wiki/Time_zone#Time_zones_and_time_offsets">Wikipedia</a>)</p> </blockquote> <p>However, a time zone does not necessarily follow the same time all year round. If there&#39;s no daylight saving time, <em>standard time</em> is followed throughout the year. If there is a <em>daylight saving time</em>, it is followed during summer. For example, the <code>America/Los_Angeles</code> time zone follows Pacific Standard Time (PST), a standard time, during winter and Pacific Daylight Saving Time (PDT), a daylight saving time, in the summer. This is an important distinction. A <em>Time</em> such as Pacific Standard Time is not a time zone, but they are often mistakenly referred to as time zones because only a single time zone uses that <em>Time</em>.</p> <p>Now that we know what a time zone is, let&#39;s dive into code. Our application is going to be used in Ecuador, that South American nation on the equator. And only there. Our assumption is:</p> <ul> <li>Ecuador follows a single <em>Time</em>, the Ecuador local time -- whatever the Ecuador officials have decided is the time.</li> </ul> <p>And the code, written with that assumption:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="c"># We receive an interesting time from the user.</span>
<span class="c"># 8:00 AM on October 5th, 2015</span>
<span class="n">user_input</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span>
    <span class="n">year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span>
    <span class="n">month</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">day</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">hour</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">minute</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>

<span class="c"># Save it in the database.</span>
<span class="n">interesting_times</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">user_input</span><span class="p">)</span>

<span class="c"># Display all interesting times to the user.</span>
<span class="k">for</span> <span class="n">interesting_time</span> <span class="ow">in</span> <span class="n">interesting_times</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">interesting_time</span>
</code></pre> <p>Our simple application saves interesting times to a database, where we can fetch them later to display to the users.</p> <p>Let&#39;s assess if there are any problem cases with user input.</p> <ul> <li>Ecuador doesn&#39;t have daylight saving time, so there are no transitions.</li> <li>The Ecuador mainland resides within a single time zone (the Galápagos Islands are an hour behind, but we&#39;ll ignore them), so all the times submitted by users should adhere to the same time standard.</li> </ul> <p>Our assumption remains intact.</p> <p>If you think back to UTC and how it relates to the Sun on the equator, we are in a similar situation. Ecuador is on the equator. The local time was (hopefully) established by the officials by setting noon to when the Sun is at its highest on average, just like mean solar time. We&#39;re only using a different longitude than UTC. Using a different base than UTC is fine for our case, because we&#39;re only concerned with Ecuadorian local times.</p> <p>This is the only situation where we could <em>consider</em> using naïve local time in our application. I put emphasis on consider, because of what happens when we make our assumptions stricter.</p> <ul> <li>Ecuador <em>did not have</em>, doesn&#39;t currently have, nor <em>will ever have during the lifetime of our application</em>, a transition to a different time.</li> </ul> <p>Okay, that&#39;s pretty strict. Let&#39;s see. Countries near the equator don&#39;t have a large variance in daylight duration to warrant a daylight saving time. You&#39;d think that would cover our asses for the past and future, and it would, if it weren&#39;t for this guy called Sixto Durán Ballén.</p> <p>As the President of Ecuador, he imposed a daylight saving time in 1992. The people hated it though, and they quickly scrapped it. I&#39;d say the transitions to daylight saving time and back to standard Ecuador time were <code>interesting_times</code>, no?</p> <p>Let&#39;s assume that the time was moved forward 1 hour in Ecuador on <code>03:00 AM</code>, March 8th, 1992. One second after <code>02:59:59 AM</code>, the official time was <code>04:00:00 AM</code>. With our current software implementation, the user could now input an invalid time. None of the times between <code>03:00:00 AM</code> to <code>03:59:59 AM</code> on March 8th, 1992 occurred. <code>datetime</code> doesn&#39;t know nor care.</p> <p>That might not lead to big bugs, but let&#39;s consider another effect of that time transition. What if our application wanted to show the duration between the two interesting times? Julio decides to submit <code>02:00 AM</code>, March 8th, 1992 as an interesting time because he met his future ex-wife in a local bar in Quito. That&#39;s one hour before the time transition. The wedding was set for the next day at <code>02:00 PM</code>, March 8th, 1992. Julio wants to know the duration between these two very <code>interesting_times</code>. Our naïve implemenation would calculate it like so:</p> <pre class="highlight python"><code><span class="c"># 02:00AM, March 8th, 1992</span>
<span class="n">first_meeting_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span>
    <span class="n">year</span><span class="o">=</span><span class="mi">1992</span><span class="p">,</span>
    <span class="n">month</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">day</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">hour</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">minute</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># 02:00PM, March 9th, 1992</span>
<span class="n">wedding_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span>
    <span class="n">year</span><span class="o">=</span><span class="mi">1992</span><span class="p">,</span>
    <span class="n">month</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">day</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">hour</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
    <span class="n">minute</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">duration</span> <span class="o">=</span> <span class="n">wedding_time</span> <span class="o">-</span> <span class="n">first_meeting_time</span>
<span class="c"># timedelta(hours=12)</span>
</code></pre> <p>Julio brags to his friends how he got married 12 hours after the first date. He would be acting too humble, ofcourse, as the duration was only 11 hours; a far brag-worthier achievement.</p> <p>How do we deal with these cases? We could write if-conditions to deal with the daylight saving time transitions, since in Ecuador there were only two transitions. We shouldn&#39;t though, because Python offers a package that makes it really easy called <code>pytz</code>. It corrects <code>datetime</code> usage with information from the <a href="http://www.iana.org/time-zones">Olson Database</a>, also called the tz database, which is basically historical data on what <em>Time</em> was used, when and in which timezone. It&#39;s not perfect, as I found out. It knows that there was a daylight saving time experiment in Ecuador in 1992, but no one knows the exact dates. Here&#39;s the entry:</p> <pre class="highlight plaintext"><code># Ecuador
#
# Milne says the Central and South American Telegraph Company used -5:24:15.
#
# From Paul Eggert (2007-03-04):
# Apparently Ecuador had a failed experiment with DST in 1992.
# &lt;http://midena.gov.ec/content/view/1261/208/&gt; (2007-02-27) and
# &lt;http://www.hoy.com.ec/NoticiaNue.asp?row_id=249856&gt; (2006-11-06) both
# talk about "hora Sixto".  Leave this alone for now, as we have no data.
#
# Zone  NAME        GMTOFF  RULES   FORMAT  [UNTIL]
Zone America/Guayaquil  -5:19:20 -  LMT 1890
            -5:14:00 -  QMT 1931 # Quito Mean Time
            -5:00   -   ECT # Ecuador Time
</code></pre> <p>What do you know, there were two other transitions: one from Local Mean Time to Quito Mean Time in 1890 and another from Quito Mean Time to Ecuador Time in 1931. The lesson here is that there are edge cases you can&#39;t possibly think of, while other people have resolved them to the best collective ability. You&#39;d be a fool not to use <code>pytz</code>! It&#39;s like someone sent you a pull request that would handle all the hard edge cases in your code base, but you would decline it with a message &quot;No thanks, I&#39;m fine with having obscure bugs that will upset users and take me several days to debug and write fixes for&quot;.</p> <h2>Handling (Daylight Saving) Time Transitions</h2> <p>Enough about Ecuador. Our <code>interesting_time</code> application has received considerable interest from VC&#39;s in San Francisco, and the development team decides to move there. San Francisco follows the <code>America/Los_Angeles</code> time zone that observes daylight saving time in the summer. The application will be improved to handle the transitions and all other quirks using <code>pytz</code>. The Olson Database file on the United States is over 1000 lines long. We&#39;ll save ourselves from a lot of trouble.</p> <p>With all time transitions including Daylight Saving Time transitions, there are two cases during the transition that need to be handled:</p> <ol> <li>The local time did not occur.</li> <li>The local time occured twice.</li> </ol> <p>In San Francisco on <code>2:00 AM</code>, March 8th 2015, the time was moved forward 1 hour to transition from Pacific Standard Time (PST) to Pacific Daylight Saving Time (PDT). One second after <code>1:59:59 AM</code>, the local time was <code>3:00:00 AM</code>. The times between <code>2:00:00 AM</code> to <code>2:59:59 AM</code> did not occur. Here&#39;s a graph that illustrates the problem:</p> <p><img alt=Gap src="../images/timezones/gap.png"/></p> <p><code>Local Time</code> on the horizontal axis has a gap in the transition. Note that when looking from the vertical <code>UTC</code>axis, the graph is continuous.</p> <p>We don&#39;t want to accept <code>2:30 AM, March 8th, 2015</code> as an <code>interesting_time</code> in our application. Here&#39;s how we would use <code>pytz</code> to recognize an invalid time.</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pytz</span>

<span class="c"># This is the user input, a naive datetime.</span>
<span class="c"># We assume that the user's intention</span>
<span class="c"># is to input the time in San Francisco</span>
<span class="c"># local time.</span>
<span class="n">user_input</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span>
    <span class="n">year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span>
    <span class="n">month</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">day</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">hour</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">minute</span><span class="o">=</span><span class="mi">30</span>
<span class="p">)</span>

<span class="c"># In the Olson Database, San Francisco is under</span>
<span class="c"># a timezone called `America/Los_Angeles`. </span>
<span class="c"># We grab a corresponding time zone</span>
<span class="c"># instance from `pytz`.</span>
<span class="n">sf_timezone</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s">'America/Los_Angeles'</span><span class="p">)</span>

<span class="c"># Now we'll try to make our naive `datetime` time zone aware.</span>
<span class="c"># For this purpose, `pytz` offers a `localize` method on its</span>
<span class="c"># timezone objects that takes a naive datetime as its first argument.</span>
<span class="c"># </span>
<span class="c"># By passing `is_dst=None` keyword argument to the `localize` method,</span>
<span class="c"># we're telling `pytz` to raise an exception if it encounters a local</span>
<span class="c"># time that occurred twice or a time that did not occur. `pytz` calls these</span>
<span class="c"># times ambiguous and non-existent respectively.</span>
<span class="n">sf_timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">user_input</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="c"># Traceback (most recent call last):</span>
<span class="c">#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span>
<span class="c">#   File "/usr/local/lib/python2.7/site-packages/pytz/tzinfo.py", line 327, in localize</span>
<span class="c">#     raise NonExistentTimeError(dt)</span>
<span class="c"># pytz.exceptions.NonExistentTimeError: 2015-03-08 02:30:00</span>

</code></pre> <p><code>pytz</code> raises an exception when we try to localize a time that doesn&#39;t exist in the timezone we defined. You will have to handle this exception in your application if you don&#39;t want the user to face a server error.</p> <p>Likewise on 2:00 AM, November 1st, 2015, the time was moved back 1 hour in the <code>America/Los_Angeles</code> time zone. Local times between <code>1:00:00 AM</code> and <code>1:59:59 AM</code> occurred twice. Here&#39;s a graph of the problem:</p> <p><img alt=Gap src="../images/timezones/overlap.png"/></p> <p>Notice how for the <code>Local Time</code> values during the transition, there are two possible <code>UTC</code> values. Once again, looking from the <code>UTC</code> axis, the graph is continuous. </p> <p>We have a couple of choices on how to handle this.</p> <ul> <li>We could make <code>pytz</code> raise an exception like last time and handle it, for example, by asking the user to clarify which timezone they meant,</li> <li>let <code>pytz</code> randomly pick whether we mean Daylight Saving Time or Standard Time, or</li> <li>pass in a flag ourselves if the time is in DST or not with <code>is_dst</code>.</li> </ul> <p>Here&#39;s how we would write these solutions with <code>pytz</code>.</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pytz</span>

<span class="n">user_input</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span>
    <span class="n">year</span><span class="o">=</span><span class="mi">2015</span><span class="p">,</span>
    <span class="n">month</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span>
    <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">hour</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">minute</span><span class="o">=</span><span class="mi">30</span>
<span class="p">)</span>

<span class="n">sf_timezone</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s">'America/Los_Angeles'</span><span class="p">)</span>

<span class="c"># First solution: raise an exception.</span>
<span class="c"># Passing in `is_dst=None` raises an `AmbiguousTimeError`.</span>
<span class="n">sf_timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">user_input</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="c"># pytz.exceptions.AmbiguousTimeError: 2015-11-01 01:30:00</span>

<span class="c"># Second solution: let `pytz` randomly pick the correct Time.</span>
<span class="c"># We don't pass an `is_dst` flag</span>
<span class="n">sf_timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">user_input</span><span class="p">)</span>
<span class="c"># datetime(2015, 11, 1, 1, 30,</span>
<span class="c">#          tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PST-1 day, 16:00:00 STD&gt;)</span>

<span class="c"># Third solution: explicitly tell `pytz` which Time we want.</span>
<span class="n">sf_timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">user_input</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># datetime(2015, 11, 1, 1, 30,</span>
<span class="c">#          tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PDT-1 day, 17:00:00 DST&gt;)</span>

</code></pre> <p>You probably get it now - <code>pytz</code> is great when you want to handle all these edge cases by importing <code>pytz</code> and calling a couple functions. So if we could just use <code>pytz</code> with local time, why would you need to know anything about UTC?</p> <p>Because <code>datetime</code> arithmetic is far more complex when we&#39;re dealing with local times and time zones instead of UTC.</p> <h2>Time Arithmetic</h2> <p>Let&#39;s go back to the previous graphs. Let <code>after_dt</code> be a point in time after a time transition and let <code>X</code> be some <code>timedelta</code> time interval, so that after we subtract <code>X</code> from <code>after_dt</code>, the resulting point in time should be in a different <em>Time</em> (like daylight saving time). The problem is that <code>datetime</code> can&#39;t calculate it correctly, since it doesn&#39;t factor in time transitions. In the graphs below, what we actually receive are the red dots:</p> <p><img alt="Local Time Gap Arithmetic" src="../images/timezones/gap_arithmetic.png"/></p> <p><img alt="Local Time Overlap Arithmetic" src="../images/timezones/overlap_arithmetic.png"/></p> <p>You probably saw those blue dots, the correct values for <code>after_dt - X</code>? A <code>pytz</code> time zone instance can give us a blue dot if we pass a red dot to its <code>normalize</code> method. <code>normalize</code> might sound like magic, but it&#39;s not.</p> <p><strong>The Magical <code>normalize</code> Algorithm:</strong></p> <ol> <li>Convert the aware local time <code>datetime</code> to UTC.</li> <li>Convert it back to to local time.</li> </ol> <p>You can see how this works in the graph. We take the <code>UTC</code> value of <code>wrong</code>, and trace that <code>UTC</code> value back to a valid point on the <code>Local Time</code> graph, which leads us to the correct green dot.</p> <p><img alt="Local Time Gap Arithmetic Fixed" src="../images/timezones/gap_arithmetic_fixed.png"/></p> <p><img alt="Local Time Overlap Arithmetic Fixed" src="../images/timezones/overlap_arithmetic_fixed.png"/></p> <p>Here&#39;s how it works in the code:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">pytz</span>

<span class="n">sf_timezone</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s">'America/Los_Angeles'</span><span class="p">)</span>

<span class="c"># 3:00:00 AM, March 8th 2015 - the first moment after</span>
<span class="c"># transitioning to Pacific Daylight Saving time.</span>
<span class="c"># The previous second was 01:59:59.</span>
<span class="n">after_dt</span> <span class="o">=</span> <span class="n">sf_timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="c"># datetime(2015, 3, 8, 3, 0,</span>
<span class="c">#          tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PDT-1 day, 17:00:00 DST&gt;)</span>

<span class="c"># 2:30:00 AM on March 8th 2015 never occurred.</span>
<span class="n">wrong</span> <span class="o">=</span> <span class="n">after_dt</span> <span class="o">-</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="c"># datetime(2015, 3, 8, 2, 30,</span>
<span class="c">#          tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PDT-1 day, 17:00:00 DST&gt;)</span>

<span class="c"># pytz.normalize returns a corrected datetime,</span>
<span class="c"># 1:30:00 AM on March 8th, 2015.</span>
<span class="n">corrected</span> <span class="o">=</span> <span class="n">sf_timezone</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">wrong</span><span class="p">)</span>
<span class="c"># datetime(2015, 3, 8, 1, 30,</span>
<span class="c">#          tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PST-1 day, 16:00:00 STD&gt;)</span>
</code></pre> <p>If you look back at those graphs though, you might notice how the continuous nature of UTC would make time arithmetic simple. <code>X - Y = Z</code> and that&#39;s that.</p> <p>There are other benefits to using UTC. Not all databases have equal support for aware <code>datetime</code>s and time zones. Postgres does, but SQLite doesn&#39;t. It is also really easy to use UTC in Django. The best practice is to convert all user input to UTC when received. Here&#39;s how you would do it:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">pytz</span>

<span class="n">sf_timezone</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s">'America/Los_Angeles'</span><span class="p">)</span>

<span class="c"># 8:00 AM, June 1st 2015 in `America/Los_Angeles` timezone.</span>
<span class="n">local_dt</span> <span class="o">=</span> <span class="n">sf_timezone</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="c"># datetime(2015, 3, 8, 3, 0,</span>
<span class="c">#          tzinfo=&lt;DstTzInfo 'America/Los_Angeles' PDT-1 day, 17:00:00 DST&gt;)</span>

<span class="c"># Because `UTC` doesn't have time transitions, we don't need</span>
<span class="c"># to use `normalize`. Use this `datetime` internally in your</span>
<span class="c"># application.</span>
<span class="c"># `pytz.utc` is equivalent to pytz.timezone('UTC')</span>
<span class="n">local_dt_in_utc</span> <span class="o">=</span> <span class="n">local_dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

<span class="c"># Here's how you get the local representation back.</span>
<span class="c"># When converting to a timezone with possible time transitions, use `normalize`</span>
<span class="c"># to ensure it's correct.</span>
<span class="n">back_to_local_dt</span> <span class="o">=</span> <span class="n">sf_timezone</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">local_dt_in_utc</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">sf_timezone</span><span class="p">))</span>
</code></pre> <p>That&#39;s it, use <code>local_dt_in_utc</code> in your application internally, and calculate <code>back_to_local_dt</code> when needed to.</p> <h2>How Django Handles Time</h2> <p>The first time you set the <code>USE_TZ</code> setting set to <code>True</code>, you probably got Django nagging endlessly about <code>datetime</code>s in the console output. That&#39;s bad, because at some point you&#39;re going to try to compare a naïve and an aware <code>datetime</code>, which raises an exception. Whenever we get user input that doesn&#39;t come in through a Django form, it&#39;s naïve unless we explicitly set the time zone. However, when we get a value from a model instance that is stored in a <code>DateTimeField</code>, we get an aware <code>datetime</code> from Django. The problem here is that naïve and aware <code>datetime</code>s can&#39;t be compared. The aware datetime is in UTC or can easily be converted to UTC. With a naïve <code>datetime</code>, we just have a local time, but we dont know the location, so it can&#39;t be converted to UTC for a comparison.</p> <p>Here are the rules that follow when you set <code>USE_TZ</code> to <code>True</code>:</p> <ul> <li>Django expects aware datetimes on the database layer.</li> <li>Any value you get from a model or form field will be aware.</li> <li>If Django encounters a naïve datetime, it interprets it as local time of the current time zone and logs a warning.</li> </ul> <p>Hold up, what is the current time zone? From the Django docs:</p> <blockquote> <p>The default time zone is the time zone defined by the <code>TIME_ZONE</code> setting.</p> <p>The current time zone is the time zone that’s used for rendering.</p> <p>[...] [If the current timezone is not set, ] the default timezone is used.</p> </blockquote> <p>Unless your application has the ability to switch timezone, or you display times in different timezones within the application, the current time zone will always be the time zone you set in <code>TIME_ZONE</code>. Moving on.</p> <ul> <li>Naive datetimes entered in forms will be interpreted in the current timezone, so they will be aware if you access <code>cleaned_data</code> or when calling <code>.save</code> on a <code>ModelForm</code>.</li> <li>When rendering aware datetimes in Django templates, they will be represented in the current time zone. Naive datetimes are presented as-is.</li> </ul> <p>And that is basically it. For our application based in San Francisco, we would use <code>USE_TZ = True</code> and <code>TIME_ZONE = &#39;America/Los_Angeles&#39;</code> Django would always interpret the current time zone as <code>America/Los_Angeles</code>. We would not mess this up by using naïve datetimes, but then our console output would be ugly with all the warnings Django throws at us.</p> <h3>Example Data Flow with Django Forms and Templates</h3> <p><strong>Saving a <code>datetime</code> to the database through a form</strong></p> <ol> <li>User enters <code>8:00 AM</code>, <code>June 10th 2015</code> into a Django form and submits it.</li> <li>Django checks what the current time zone is. Since we have set <code>USE_TZ</code> to <code>True</code> and we haven&#39;t explicitly set a current timezone, the value in <code>TIME_ZONE</code> will be used: <code>America/Los_Angeles</code>.</li> <li>When cleaning the form (calling <code>.is_valid</code>), the raw input field is parsed for a naive <code>datetime</code> and then converted to an aware <code>datetime</code> by interpreting it in the current time zone. Django does this by calling <code>timezone.make_aware</code> The resulting <code>datetime</code> is aware in the current time zone, not <code>UTC</code>.</li> <li>The cleaned data is saved to the database. The format the <code>datetime</code> is saved in depends on the database.</li> </ol> <p><strong>Fetching a <code>datetime</code> value from the database and displaying it through Django templates</strong></p> <ol> <li>Our user requests a page to show all <code>interesting_times</code>.</li> <li>We get the times from a model&#39;s <code>DateTimeField</code>. Django returns an aware <code>datetime</code>. The time zone info of that <code>datetime</code> instance depends on the database, but it is aware nevertheless.</li> <li>In the Django template, let&#39;s say we have a for loop that runs through all of our <code>interesting_times</code>. For each <code>interesting_time</code>, we output <code>{{ interesting_time.time }}</code>.</li> <li>Django templates checks what the current time zone is. Like before, since we haven&#39;t explicitly set it, it is <code>America/Los_Angeles</code> from the <code>TIME_ZONE</code> setting.</li> <li>Django calls <code>timezone.localtime(</code> <code>interesting_time.time,</code> <code>timezone=current_time_zone)</code> to get an aware <code>datetime</code> that represents the time with our current time zone.</li> <li>Django renders a representation of the localized, aware <code>datetime</code> to the template.</li> </ol> <h2>django.utils.timezone</h2> <p>We&#39;ve learned about time, time zones, why we need to use <code>pytz</code>, and how Django handles naive and aware datetimes and time zones. Dealing with <code>pytz</code> all the time can get exhausting. Luckily Django has a handy toolkit, <code>django.utils.timezone</code>, that makes working with <code>pytz</code> a breeze. The functions you&#39;ll be using the most are <code>timezone.now()</code> and <code>timezone.make_aware()</code> and <code>timezone.localtime()</code>. What you should do is just read their <a href="https://github.com/django/django/blob/stable/1.8.x/django/utils/timezone.py#L296">source code</a> as they are very simple functions. Here&#39;s how they work.</p> <p><strong><code>timezone.now()</code></strong></p> <p>Returns an aware <code>datetime</code> representing the current point in time in UTC. <strong>ALWAYS use this when you want to get the current time in a Django application</strong>.</p> <p><strong><code>timezone.make_aware(naive_dt)</code></strong></p> <p>Interprets <code>naive_dt</code> in the current time zone and returns an aware datetime. <strong>When you receive naive user input that doesn&#39;t pass through a form, use this function to make it aware</strong>.</p> <p><strong><code>timezone.localtime(aware_dt)</code></strong></p> <p>Returns an aware <code>datetime</code> the represents the same absolute point in time as <code>aware_dt</code>, but in the current time zone. <strong>If you need to manually convert a <code>datetime</code> for user display, use this function</strong>.</p> <h2>Converting a datetime to UTC</h2> <p><code>django.utils.timezone</code> doesn&#39;t offer a shortcut to convert a <code>datetime</code> to UTC. You could implement something like this in your own <code>utils</code> module:</p> <pre class="highlight python"><code><span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">timezone</span>
<span class="kn">import</span> <span class="nn">pytz</span>

<span class="k">def</span> <span class="nf">make_utc</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">is_naive</span><span class="p">():</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">timezone</span><span class="o">.</span><span class="n">make_aware</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
</code></pre> <p>And call that before manipulating the <code>datetime</code>.</p> <p>If you got up to this point, you&#39;ll realize it&#39;s not that hard dealing with time zones in Django. Whenever you get a naïve datetime, call <code>timezone.make_aware</code>. Whenever you want the current time, call <code>timezone.now</code>. Before doing any time arithmetic, convert the datetime to <code>UTC</code> with <code>dt.astimezone(pytz.utc)</code>. If you&#39;re passing an aware <code>datetime</code> to the user through Django templates, let Django take care of the conversion to local time implicitly. If you&#39;re making a representation of the time that won&#39;t be passed through Django templates, use <code>timezone.localtime</code> to convert the timezone to the current timezone before passing the value on.</p> <h2>Conclusion</h2> <p>There you have it. We covered the concept of time, UTC, time zones, looked at the problems in time transitions, how <code>pytz</code> deals with them, and how to manage time zones in <code>Django</code>.</p> <p>If you encounter problems with a <code>datetime</code> value, remember to start from the basics.</p> <ul> <li>In what format is the <code>datetime</code>? <ul> <li>If aware, in what time zone?</li> <li>If naive, what time zone should it represent?</li> </ul></li> <li>What format do I want it to be in?</li> <li>How do I bridge the gap between the two?</li> </ul> <p>If you don&#39;t know the current format or the target format, you need to figure those out before doing anything else.</p> <p>To minimize these problems, you should convert <code>datetime</code>s to an internal representation as early as possible, and convert back to display format as late as possible. UTC is safe, everything else is not. Django takes care of this for you in most cases, but you need to remember this when receiving input outside views and forms, and writing output outside templates.</p> </article> <footer> <div class=content-wrapper> <p> Follow me on Twitter: <a href="https://twitter.com/tommikaikkonen">@tommikaikkonen</a>.<br/> <a href="/">Back to home</a> </p> </div> </footer> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71106705-1', 'auto');
  ga('send', 'pageview');
</script> </body> </html>